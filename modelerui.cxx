// generated by Fast Light User Interface Designer (fluid) version 1.00
#pragma warning( disable : 4786 )

#include "modelerui.h"
#include "modelerapp.h"
#include "IKSolver.h"

#include "camera.h"

#if _MSC_VER >= 1300

#include <iostream>

#else //  _MSC_VER >= 1300

#include <iostream.h>

#endif // _MSC_VER >= 1300

#include <string>
#include <fstream>
using namespace std;

extern IKSolver solver;

inline void ModelerUserInterface::cb_m_controlsWindow_i(Fl_Window*, void*) {
  0;;
}
void ModelerUserInterface::cb_m_controlsWindow(Fl_Window* o, void* v) {
  ((ModelerUserInterface*)(o->user_data()))->cb_m_controlsWindow_i(o,v);
}

void ModelerUserInterface::cb_chooseEndEffector(Fl_Widget* o, void* v)
{
	int value = (int)v;
	solver.setBoneChain(static_cast<IKSolver::EndEffector>((int)v));
}

void ModelerUserInterface::cb_solveIk(Fl_Widget* o, void*)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	solver.show_ik_result = true;
	solver.offset = aiVector3D(ui->m_xPosInput->value(), ui->m_yPosInput->value(), ui->m_zPosInput->value());
	solver.setContext();
	solver.solve();
	ui->m_modelerView->redraw();
}

void ModelerUserInterface::cb_closeIkDialog(Fl_Window* o, void* v)
{
	solver.show_ik_result = false;
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	ui->m_modelerView->redraw();
	Fl_Window::default_callback(o, v);
}

void ModelerUserInterface::cb_jointChoice(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	int choice = solver.constraints.size() - 1 - (int)v;
	choice = max(0, choice);
	ui->jointChoice = choice;

	auto& constraint = solver.constraints[choice];
	ui->m_yawMaxSlider->value(constraint.max_yaw_angle);
	ui->m_yawMinSlider->value(constraint.min_yaw_angle);
	ui->m_pitchMaxSlider->value(constraint.max_pitch_angle);
	ui->m_pitchMinSlider->value(constraint.min_pitch_angle);
	ui->m_rollMaxSlider->value(constraint.max_roll_angle);
	ui->m_rollMinSlider->value(constraint.min_roll_angle);

	ui->m_enablePitch->value(constraint.enable_pitch);
	ui->m_enableRoll->value(constraint.enable_roll);
	ui->m_enableYaw->value(constraint.enable_yaw);
}

void ModelerUserInterface::cb_yawMax(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.max_yaw_angle = slider->value();
}

void ModelerUserInterface::cb_yawMin(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.min_yaw_angle = slider->value();
}

void ModelerUserInterface::cb_pitchMax(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.max_pitch_angle = slider->value();
}

void ModelerUserInterface::cb_pitchMin(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.min_pitch_angle = slider->value();
}

void ModelerUserInterface::cb_rollMax(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.max_roll_angle = slider->value();
}

void ModelerUserInterface::cb_rollMin(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* slider = (Fl_Slider*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.min_roll_angle = slider->value();
}

void ModelerUserInterface::cb_enableConstraints(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* check_box = (Fl_Check_Button*)o;
	solver.enable_constraints = check_box->value();
}

void ModelerUserInterface::cb_enableYaw(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* check_box = (Fl_Check_Button*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.enable_yaw = check_box->value();
}

void ModelerUserInterface::cb_enablePitch(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* check_box = (Fl_Check_Button*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.enable_pitch = check_box->value();
}

void ModelerUserInterface::cb_enableRoll(Fl_Widget* o, void* v)
{
	auto* ui = ((ModelerUserInterface*)(o->user_data()));
	auto* check_box = (Fl_Check_Button*)o;
	auto& constraint = solver.constraints[ui->jointChoice];
	constraint.enable_roll = check_box->value();
}

inline void ModelerUserInterface::cb_Save_i(Fl_Menu_*, void*) {
  char *filename = NULL;
filename = fl_file_chooser("Save RAY File", "*.ray", NULL);
if (filename)
{
	if (openRayFile(filename) == false)
		fl_alert("Error opening file.");
	else
	{
		m_modelerView->draw();
		closeRayFile();
	}
};
}
void ModelerUserInterface::cb_Save(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

inline void ModelerUserInterface::cb_Save1_i(Fl_Menu_*, void*) {
  char *filename = NULL;
filename = fl_file_chooser("Save BMP File", "*.bmp", NULL);
if (filename)
{
	int x = m_modelerView->x();
	int y = m_modelerView->y();
	int w = m_modelerView->w();
	int h = m_modelerView->h();

	m_modelerWindow->show();
//	do {Sleep(10); }
//	while (!m_modelerWindow->shown());
//	m_modelerView->draw();
	m_modelerView->make_current();
m_modelerView->draw();
	
		
	unsigned char *imageBuffer = new unsigned char[3*w*h];

        // Tell openGL to read from the front buffer when capturing
        // out paint strokes
        glReadBuffer(GL_BACK);

        glPixelStorei( GL_PACK_ALIGNMENT, 1 );
        glPixelStorei( GL_PACK_ROW_LENGTH, w );
        
        glReadPixels( 0, 0, w, h, 
                GL_RGB, GL_UNSIGNED_BYTE, 
                imageBuffer );


	writeBMP(filename, w,h, imageBuffer);

	delete [] imageBuffer;
};
}
void ModelerUserInterface::cb_Save1(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Save1_i(o,v);
}

// IANLI
// Implementation callback for saving the positions of the model into a file
// The first line of the file contains the values for the position/orientation of
// the camera. The values are ordered as the following:
//		elevation azimuth dolly twist lookAtX lookAtY lookAtZ
// The lines after correspond to the values of the controls. The following lines 
// have this format:
//		controlNumber controlValue
inline void ModelerUserInterface::cb_SavePos_i(Fl_Menu_*, void*) {
	char *filename = NULL;
	filename = fl_file_chooser("Save .pos File", "*.pos", NULL);

	if (filename)
	{
		FILE* m_posFile = fopen(filename, "w");

		float elevation, azimuth, dolly, twist;
		Vec3f lookAt;
		elevation = m_modelerView->m_camera->getElevation();
		dolly = m_modelerView->m_camera->getDolly();
		azimuth = m_modelerView->m_camera->getAzimuth();
		twist = m_modelerView->m_camera->getTwist();
		lookAt = m_modelerView->m_camera->getLookAt();

		fprintf(m_posFile, "%f %f %f %f %f %f %f\n", elevation, azimuth, dolly, twist, lookAt[0], lookAt[1], lookAt[2]);

		double value;
		for(int i = 0; i < NUMCONTROLS; i++)
		{
			value = ModelerApplication::Instance()->GetControlValue(i);

			fprintf(m_posFile, "%d %f\n", i, value);
		}

		fclose(m_posFile);
	};
}
void ModelerUserInterface::cb_SavePos(Fl_Menu_* o, void* v) {
	((ModelerUserInterface*)(o->parent()->user_data()))->cb_SavePos_i(o,v);
}

inline void ModelerUserInterface::cb_OpenPos_i(Fl_Menu_*, void*) {
	char *filename = NULL;
	filename = fl_file_chooser("Open .pos File", "*.pos", NULL);

	if (filename)
	{
		ifstream ifs( filename );
		if( !ifs ) {
			cerr << "Error: couldn't read position file " << filename << endl;
			return;
		}

		float elevation, azimuth, dolly, twist, x, y, z;
		ifs >> elevation >> azimuth >> dolly >> twist >> x >> y >> z;
		
		m_modelerView->m_camera->setElevation( elevation);
		m_modelerView->m_camera->setAzimuth( azimuth );
		m_modelerView->m_camera->setDolly( dolly );
		m_modelerView->m_camera->setTwist( twist );
		m_modelerView->m_camera->setLookAt( Vec3f(x, y, z) );
		
		int controlNum; 
		float value;
		while( ifs >> controlNum >> value )
		{
			if( controlNum >= NUMCONTROLS ) {
				break;
			}
			
			ModelerApplication::Instance()->SetControlValue(controlNum, value);
		}

		m_modelerView->redraw();
	};
}
void ModelerUserInterface::cb_OpenPos(Fl_Menu_* o, void* v) {
	((ModelerUserInterface*)(o->parent()->user_data()))->cb_OpenPos_i(o,v);
}

inline void ModelerUserInterface::cb_Exit_i(Fl_Menu_*, void*) {
  m_controlsWindow->hide();
m_modelerWindow->hide();
}  
void ModelerUserInterface::cb_Exit(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

inline void ModelerUserInterface::cb_FrameAll_i(Fl_Menu_* o, void* v) {
	m_modelerView->enableFrame = TRUE;
	m_modelerView->redraw();
}
void ModelerUserInterface::cb_FrameAll(Fl_Menu_* o, void* v) {
	((ModelerUserInterface*)(o->parent()->user_data()))->cb_FrameAll_i(o, v);
}

void ModelerUserInterface::cb_showIkDialog(Fl_Menu_* o, void*)
{
	((ModelerUserInterface*)(o->parent()->user_data()))->m_ikDialog->show();
}

inline void ModelerUserInterface::cb_Normal_i(Fl_Menu_*, void*) {
  setDrawMode(NORMAL);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Normal(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Normal_i(o,v);
}

inline void ModelerUserInterface::cb_Flat_i(Fl_Menu_*, void*) {
  setDrawMode(FLATSHADE);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Flat(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Flat_i(o,v);
}

inline void ModelerUserInterface::cb_Wireframe_i(Fl_Menu_*, void*) {
  setDrawMode(WIREFRAME);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Wireframe(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Wireframe_i(o,v);
}

inline void ModelerUserInterface::cb_High_i(Fl_Menu_*, void*) {
  setQuality(HIGH);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_High(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_High_i(o,v);
}

inline void ModelerUserInterface::cb_Medium_i(Fl_Menu_*, void*) {
  setQuality(MEDIUM);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Medium(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Medium_i(o,v);
}

inline void ModelerUserInterface::cb_Low_i(Fl_Menu_*, void*) {
  setQuality(LOW);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Low(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Low_i(o,v);
}

inline void ModelerUserInterface::cb_Poor_i(Fl_Menu_*, void*) {
  setQuality(POOR);
m_modelerView->redraw();
}
void ModelerUserInterface::cb_Poor(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_Poor_i(o,v);
}

// Callback function to look at origin again.
inline void ModelerUserInterface::cb_Focus_i(Fl_Menu_*, void*) {
	m_modelerView->m_camera->setLookAt( Vec3f(0, 0, 0) );
	m_modelerView->redraw();
}
void ModelerUserInterface::cb_Focus(Fl_Menu_* o, void* v) {
	((ModelerUserInterface*)(o->parent()->user_data()))->cb_Focus_i(o,v);
}

inline void ModelerUserInterface::cb_m_controlsAnimOnMenu_i(Fl_Menu_*, void*) {
  ModelerApplication::Instance()->m_animating = (m_controlsAnimOnMenu->value() == 0) ? false : true;
}
void ModelerUserInterface::cb_m_controlsAnimOnMenu(Fl_Menu_* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_m_controlsAnimOnMenu_i(o,v);
}

Fl_Menu_Item ModelerUserInterface::menu_m_controlsMenuBar[] = {
 {"File", 0,  0, 0, 64, 0, 0, 14, 0},
 {"Frame All", 0,  (Fl_Callback*)ModelerUserInterface::cb_FrameAll, 0, 0, 0, 0, 14, 0},
 {"Save Raytracer File", 0,  (Fl_Callback*)ModelerUserInterface::cb_Save, 0, 0, 0, 0, 14, 0},
 {"Save Bitmap File", 0,  (Fl_Callback*)ModelerUserInterface::cb_Save1, 0, 128, 0, 0, 14, 0},
 {"Open Position File", 0, (Fl_Callback*)ModelerUserInterface::cb_OpenPos, 0, 0, 0, 0, 14, 0},
 {"Save Position File", 0, (Fl_Callback*)ModelerUserInterface::cb_SavePos, 0, 128, 0, 0, 14, 0},
 {"Exit", 0,  (Fl_Callback*)ModelerUserInterface::cb_Exit, 0, 0, 0, 0, 14, 0},
 {0},
 {"View", 0,  0, 0, 64, 0, 0, 14, 0},
 {"Normal", 0,  (Fl_Callback*)ModelerUserInterface::cb_Normal, 0, 12, 0, 0, 14, 0},
 {"Flat Shaded", 0,  (Fl_Callback*)ModelerUserInterface::cb_Flat, 0, 8, 0, 0, 14, 0},
 {"Wireframe", 0,  (Fl_Callback*)ModelerUserInterface::cb_Wireframe, 0, 136, 0, 0, 14, 0},
 {"High Quality", 0,  (Fl_Callback*)ModelerUserInterface::cb_High, 0, 8, 0, 0, 14, 0},
 {"Medium Quality", 0,  (Fl_Callback*)ModelerUserInterface::cb_Medium, 0, 12, 0, 0, 14, 0},
 {"Low Quality", 0,  (Fl_Callback*)ModelerUserInterface::cb_Low, 0, 8, 0, 0, 14, 0},
 {"Poor Quality", 0,  (Fl_Callback*)ModelerUserInterface::cb_Poor, 0, 136, 0, 0, 14, 0},
 {"Focus on Origin", 0,  (Fl_Callback*)ModelerUserInterface::cb_Focus, 0, 0, 0, 0, 14, 0},
 {0},
 {"Animate", 0,  0, 0, 64, 0, 0, 14, 0},
 {"Enable", 0,  (Fl_Callback*)ModelerUserInterface::cb_m_controlsAnimOnMenu, 0, 2, 0, 0, 14, 0},
 {0},
	{"IK Solver", 0, (Fl_Callback*)ModelerUserInterface::cb_showIkDialog, 0, 0},
	{0},
 {0}
};

using EndEffector = IKSolver::EndEffector;
Fl_Menu_Item ModelerUserInterface::m_endEffectorMenu[] =
{
	{"Head", 0, (Fl_Callback*)ModelerUserInterface::cb_chooseEndEffector, (void*)EndEffector::HEAD},
	{"Left Fore Foot", 0, (Fl_Callback*)ModelerUserInterface::cb_chooseEndEffector, (void*)EndEffector::LEFT_FORE_FOOT},
	{"Right Fore Foot", 0, (Fl_Callback*)ModelerUserInterface::cb_chooseEndEffector, (void*)EndEffector::RIGHT_FORE_FOOT},
	{"Left Rear Foot", 0, (Fl_Callback*)ModelerUserInterface::cb_chooseEndEffector, (void*)EndEffector::LEFT_REAR_FOOT},
	{"Right Rear Foot", 0, (Fl_Callback*)ModelerUserInterface::cb_chooseEndEffector, (void*)EndEffector::RIGHT_REAR_FOOT},
	{0}
};

Fl_Menu_Item ModelerUserInterface::m_jointMenu[] =
{
	{"Root Joint", 0, (Fl_Callback*)ModelerUserInterface::cb_jointChoice, (void*)0},
	{"Second Joint", 0, (Fl_Callback*)ModelerUserInterface::cb_jointChoice, (void*)1},
	{"Third Joint", 0, (Fl_Callback*)ModelerUserInterface::cb_jointChoice, (void*)2},
	{0}
};

// 11-01-2001: fixed bug that caused animation problems
Fl_Menu_Item* ModelerUserInterface::m_controlsAnimOnMenu = ModelerUserInterface::menu_m_controlsMenuBar + 19;

inline void ModelerUserInterface::cb_m_controlsBrowser_i(Fl_Browser*, void*) {
  for (int i=0; i<ModelerApplication::Instance()->m_numControls; i++) {
	if (m_controlsBrowser->selected(i+1))
		ModelerApplication::Instance()->ShowControl(i);
	else
		ModelerApplication::Instance()->HideControl(i);
};
}
void ModelerUserInterface::cb_m_controlsBrowser(Fl_Browser* o, void* v) {
  ((ModelerUserInterface*)(o->parent()->user_data()))->cb_m_controlsBrowser_i(o,v);
}

inline void ModelerUserInterface::cb_m_modelerWindow_i(Fl_Window*, void*) {
  0;
}
void ModelerUserInterface::cb_m_modelerWindow(Fl_Window* o, void* v) {
  ((ModelerUserInterface*)(o->user_data()))->cb_m_modelerWindow_i(o,v);
}

ModelerUserInterface::ModelerUserInterface() {
  Fl_Window* w;
  { Fl_Window* o = m_controlsWindow = new Fl_Window(395, 326, "CS 341 Modeler (SP02)");
    w = o;
    o->callback((Fl_Callback*)cb_m_controlsWindow, (void*)(this));
    o->when(FL_WHEN_NEVER);
    { Fl_Menu_Bar* o = m_controlsMenuBar = new Fl_Menu_Bar(0, 0, 395, 25);
      o->menu(menu_m_controlsMenuBar);
    }
    { Fl_Browser* o = m_controlsBrowser = new Fl_Browser(0, 25, 140, 300, "Controls");
      o->type(3);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_m_controlsBrowser);
      Fl_Group::current()->resizable(o);
    }
    { Fl_Scroll* o = m_controlsScroll = new Fl_Scroll(145, 25, 250, 300);
      o->type(6);
      o->when(FL_WHEN_CHANGED);
      { Fl_Pack* o = m_controlsPack = new Fl_Pack(145, 25, 225, 300);
        o->end();
      }
      o->end();
    }
    o->end();
  }
  { Fl_Window* o = m_modelerWindow = new Fl_Window(340, 296, "Model");
    w = o;
    o->callback((Fl_Callback*)cb_m_modelerWindow, (void*)(this));
    o->when(FL_WHEN_NEVER);
    { ModelerView* o = m_modelerView = new ModelerView(0, 0, 340, 295, "ModelerView");
      Fl_Group::current()->resizable(o);
    }
    o->end();
  }

	m_ikDialog = new Fl_Window(700, 300, "Inverse Kinetics");
	m_ikDialog->user_data(this);
	m_ikDialog->callback((Fl_Callback*)cb_closeIkDialog);
	
	m_endEffectorChoice = new Fl_Choice(100, 30, 150, 25, "End Effector");
	m_endEffectorChoice->user_data(this);
	m_endEffectorChoice->menu(m_endEffectorMenu);
	m_endEffectorChoice->callback(cb_chooseEndEffector);

	m_xPosInput = new Fl_Value_Input(70, 70, 100, 25, "X Pos");
	m_xPosInput->range(-20, 20);
	m_xPosInput->step(0.01);

	m_yPosInput = new Fl_Value_Input(220, 70, 100, 25, "Y Pos");
	m_yPosInput->range(-20, 20);
	m_yPosInput->step(0.01);

	m_zPosInput = new Fl_Value_Input(370, 70, 100, 25, "Z Pos");
	m_zPosInput->range(-20, 20);
	m_zPosInput->step(0.01);

	m_solveIkButton = new Fl_Button(300, 250, 100, 30, "Solve");
	m_solveIkButton->user_data(this);
	m_solveIkButton->callback(cb_solveIk);


	m_jointChoice = new Fl_Choice(300, 30, 150, 25, "Joint");
	m_jointChoice->user_data(this);
	m_jointChoice->menu(m_jointMenu);
	m_jointChoice->callback(cb_jointChoice);
	
	m_yawMaxSlider = new Fl_Value_Slider(430, 110, 250, 20, "Max Yaw Angle");
	m_yawMaxSlider->range(0, 180);
	m_yawMaxSlider->step(0.01);
	m_yawMaxSlider->user_data(this);
	m_yawMaxSlider->callback(cb_yawMax);
	m_yawMaxSlider->value(180);
	m_yawMaxSlider->type(FL_HORIZONTAL);

    m_yawMinSlider = new Fl_Value_Slider(150, 110, 250, 20, "Min Yaw Angle");
    m_yawMinSlider->range(-180, 0);
    m_yawMinSlider->step(0.01);
    m_yawMinSlider->user_data(this);
    m_yawMinSlider->callback(cb_yawMin);
	m_yawMinSlider->value(-180);
	m_yawMinSlider->type(FL_HORIZONTAL);

	m_pitchMaxSlider = new Fl_Value_Slider(430, 150, 250, 20, "Max Pitch Angle");
	m_pitchMaxSlider->range(0, 180);
	m_pitchMaxSlider->step(0.01);
	m_pitchMaxSlider->user_data(this);
	m_pitchMaxSlider->callback(cb_pitchMax);
	m_pitchMaxSlider->value(180);
	m_pitchMaxSlider->type(FL_HORIZONTAL);

    m_pitchMinSlider = new Fl_Value_Slider(150, 150, 250, 20, "Min Pitch Angle");
    m_pitchMinSlider->range(-180, 0);
    m_pitchMinSlider->step(0.01);
    m_pitchMinSlider->user_data(this);
    m_pitchMinSlider->callback(cb_pitchMin);
	m_pitchMinSlider->value(-180);
	m_pitchMinSlider->type(FL_HORIZONTAL);

	m_rollMaxSlider = new Fl_Value_Slider(430, 190, 250, 20, "Max Roll Angle");
	m_rollMaxSlider->range(0, 180);
	m_rollMaxSlider->step(0.01);
	m_rollMaxSlider->user_data(this);
	m_rollMaxSlider->callback(cb_rollMax);
	m_rollMaxSlider->value(180);
	m_rollMaxSlider->type(FL_HORIZONTAL);

    m_rollMinSlider = new Fl_Value_Slider(150, 190, 250, 20, "Min Roll Angle");
    m_rollMinSlider->range(-180, 0);
    m_rollMinSlider->step(0.01);
    m_rollMinSlider->user_data(this);
    m_rollMinSlider->callback(cb_rollMin);
	m_rollMinSlider->value(-180);
	m_rollMinSlider->type(FL_HORIZONTAL);


	m_enableConstraints = new Fl_Check_Button(480, 30, 60, 25, "Enable Constraints");
	m_enableConstraints->user_data(this);
	m_enableConstraints->callback(cb_enableConstraints);
	m_enableConstraints->value(0);
	
	m_enableYaw = new Fl_Check_Button(30, 110, 70, 25, "Enable Yaw");
	m_enableYaw->user_data(this);
	m_enableYaw->callback(cb_enableYaw);
	m_enableYaw->value(1);
	
	m_enablePitch = new Fl_Check_Button(30, 150, 70, 25, "Enable Pitch");
	m_enablePitch->user_data(this);
	m_enablePitch->callback(cb_enablePitch);
	m_enablePitch->value(1);

	m_enableRoll = new Fl_Check_Button(30, 190, 70, 25, "Enable Roll");
	m_enableRoll->user_data(this);
	m_enableRoll->callback(cb_enableRoll);
	m_enableRoll->value(1);

	m_ikDialog->end();
}

void ModelerUserInterface::show() {
  m_controlsWindow->show();
m_modelerWindow->show();
m_modelerView->show();
}
